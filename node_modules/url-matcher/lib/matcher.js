'use strict';

exports.__esModule = true;
exports._clearCache = _clearCache;
exports.getRoute = getRoute;
exports.matchPattern = matchPattern;
exports.formatPattern = formatPattern;
exports.getParams = getParams;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _regexUtils = require('./regexUtils');

var _rules = require('./rules');

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var routeCache = {};

// only for debug purposes

function _clearCache() {
  routeCache = {};
}

function _createRoute(_ref2) {
  var pattern = _ref2.pattern;
  var rules = _ref2.rules;

  var regex = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)|[^:*()]+/g;
  var tokens = [],
      params = [];
  var regexpSource = '';

  // Make leading slashes consistent between pattern and pathname.
  if (pattern.charAt(0) !== '/') {
    pattern = '/' + pattern;
  }

  var matches = _regexUtils.getAllMatches(regex, pattern);
  for (var _iterator = matches, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var token = _ref[0];
    var paramName = _ref[1];

    var rule = undefined;

    if (paramName) {
      // it matched a 'parameter'
      rule = rules[paramName] || _rules.string();
    } else if (token == '**') {
      rule = _rules.greedySplat();
      paramName = 'splat';
    } else if (token == '*') {
      rule = _rules.splat();
      paramName = 'splat';
    } else if (token === '(') {
      regexpSource += '(?:';
    } else if (token === ')') {
      regexpSource += ')?';
    } else {
      // anything else
      regexpSource += _regexUtils.escapeSource(token);
    }

    if (paramName) {
      regexpSource += rule.regex;
      params.push({ paramName: paramName, rule: rule });
    }

    tokens.push(token);
  }

  // Special-case patterns like '*' for catch-all routes.
  var captureRemaining = tokens[tokens.length - 1] !== '*';
  var ending = captureRemaining ? '' : '$';

  regexpSource = new RegExp('^' + regexpSource + '/*' + ending, 'i');

  return {
    tokens: tokens,
    regexpSource: regexpSource,
    params: params,
    paramNames: params.map(function (p) {
      return p.paramName;
    })
  };
}

function _validateRules(paramValues, params) {
  return paramValues.every(function (param, i) {
    return params[i].rule.validate(param);
  });
}

function _normalizeRoute(route) {
  // if the route is of type string, convert it to a route object
  if (typeof route === 'string') {
    route = {
      pattern: route,
      rules: {}
    };
  }
  _invariant2['default'](route.pattern, 'you cannot use an empty route pattern');
  // default rules to empty object
  route.rules = route.rules || {};
  return route;
}

function getRoute(route) {
  route = _normalizeRoute(route);
  if (!routeCache[route.pattern]) {
    routeCache[route.pattern] = _createRoute(route);
  }
  return routeCache[route.pattern];
}

/**
 * Matches a pathname with a specified pattern
 */

function matchPattern(route, pathname) {
  if (pathname.charAt(0) !== '/') pathname = '/' + pathname;

  var _getRoute = getRoute(route);

  var regexpSource = _getRoute.regexpSource;
  var params = _getRoute.params;
  var paramNames = _getRoute.paramNames;

  var match = pathname.match(regexpSource);

  if (match == null) return;

  var remainingPathname = pathname.slice(match[0].length);
  if (remainingPathname[0] == '/' || match[0][match[0].length]) {
    return;
  }

  var paramValues = match.slice(1).map(function (v) {
    return v != null ? decodeURIComponent(v) : v;
  });

  if (!_validateRules(paramValues, params)) return;

  // convert the parameters
  paramValues = paramValues.map(function (v, i) {
    return params[i].rule.convert(v);
  });

  return {
    remainingPathname: remainingPathname,
    paramValues: paramValues,
    paramNames: paramNames
  };
}

/**
 * Returns a version of the given pattern with params interpolated. Throws
 * if there is a dynamic segment of the pattern for which there is no param.
 */

function formatPattern(route, params) {
  params = params || {};

  var _getRoute2 = getRoute(route);

  var tokens = _getRoute2.tokens;

  var parenCount = 0,
      pathname = '',
      splatIndex = 0;

  var token = undefined,
      paramName = undefined,
      paramValue = undefined;
  for (var i = 0, len = tokens.length; i < len; ++i) {
    token = tokens[i];

    if (token === '*' || token === '**') {
      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;

      _invariant2['default'](paramValue != null || parenCount > 0, 'Missing splat #%s for path "%s"', splatIndex, route.pattern);

      if (paramValue != null) pathname += encodeURI(paramValue);
    } else if (token === '(') {
      parenCount += 1;
    } else if (token === ')') {
      parenCount -= 1;
    } else if (token.charAt(0) === ':') {
      paramName = token.substring(1);
      paramValue = params[paramName];

      _invariant2['default'](paramValue != null || parenCount > 0, 'Missing "%s" parameter for path "%s"', paramName, route.pattern);

      if (paramValue != null) pathname += encodeURIComponent(paramValue);
    } else {
      pathname += token;
    }
  }

  return pathname.replace(/\/+/g, '/');
}

function getParams(route, pathname) {
  var _ref3 = matchPattern(route, pathname) || {};

  var paramNames = _ref3.paramNames;
  var paramValues = _ref3.paramValues;

  var dic = [];
  if (!paramNames) return null;

  for (var i = 0; i < paramNames.length; i++) {
    dic[paramNames[i]] = paramValues[i];
  }
  return dic;
}